diff --git a/src/Tape.cpp b/src/Tape.cpp
index 5441fdc..908e7eb 100644
--- a/src/Tape.cpp
+++ b/src/Tape.cpp
@@ -531,24 +531,6 @@ void Tape<T>::computeAdjointsTo(position_type pos)
         computeAdjointsToImpl(pos, start);
 }
 
-namespace detail
-{
-
-template <class T>
-XAD_FORCE_INLINE T fused_multiply_add(const T& a, const T& b, const T& c)
-{
-    return c + (a * b);
-}
-
-XAD_FORCE_INLINE double fused_multiply_add(double a, double b, double c)
-{
-    return std::fma(a, b, c);
-}
-
-XAD_FORCE_INLINE float fused_multiply_add(float a, float b, float c) { return std::fma(a, b, c); }
-
-}  // namespace detail
-
 template <class T>
 void Tape<T>::computeAdjointsToImpl(position_type pos, position_type start)
 {
@@ -585,46 +567,11 @@ void Tape<T>::computeAdjointsToImpl(position_type pos, position_type start)
             {
                 for (auto opi = it[-1].first, ope = st.first; opi != ope; ++opi)
                 {
-                //  std::cout << ope - opi << "step" << sizeof(opi)<<'\n'; 
+             
                     auto multiplier = multiplier_[opi];
                     auto slot = slot_[opi];
-                    auto& der = derivatives_[slot];
-                    der = detail::fused_multiply_add(multiplier, a, der);
-                    // derivatives_[slot] = (multiplier * a) + derivatives_[slot];
+                    derivatives_[slot] += multiplier * a;
                 }
-
-                // auto opi = it[-1].first;
-                // auto ope = st.first;
-                // if (ope - opi >= 4)
-                // {
-                //     auto multiplier0 = multiplier_[opi];
-                //     auto slot0 = slot_[opi];
-                //     auto& der0 = derivatives_[slot0];
-                //     der0 = multiplier0* a + der0;
-                //     opi++;
-                //     auto multiplier1 = multiplier_[opi];
-                //     auto slot1 = slot_[opi];
-                //     auto& der1 = derivatives_[slot1];
-                //     der1 = multiplier1* a + der1;
-                //     opi++;
-                //     auto multiplier2 = multiplier_[opi];
-                //     auto slot2 = slot_[opi];
-                //     auto& der2 = derivatives_[slot2];
-                //     der2 = multiplier2* a + der2;
-                //     opi++;
-                //     auto multiplier3 = multiplier_[opi];
-                //     auto slot3 = slot_[opi];
-                //     auto& der3 = derivatives_[slot3];
-                //     der3 = multiplier3* a + der3;
-                //     opi++;
-                // }
-                // for (;opi != ope ; ++opi) 
-                // {
-                //     auto multiplier = multiplier_[opi];
-                //     auto slot = slot_[opi];
-                //     auto& der = derivatives_[slot];
-                //     der = multiplier * a + der;
-                // }
             }
         }
         // last iteration separate
@@ -638,8 +585,9 @@ void Tape<T>::computeAdjointsToImpl(position_type pos, position_type start)
             {
                 for (auto opi = prevendpoint, ope = st.first; opi != ope; ++opi)
                 {
-                    derivatives_[slot_[opi]] =
-                        detail::fused_multiply_add(multiplier_[opi], a, derivatives_[slot_[opi]]);
+                    auto multiplier = multiplier_[opi];
+                    auto slot = slot_[opi];
+                    derivatives_[slot] += multiplier * a;
                 }
             }
         }
diff --git a/src/XAD/ChunkContainer.hpp b/src/XAD/ChunkContainer.hpp
index a3764f4..85af45b 100644
--- a/src/XAD/ChunkContainer.hpp
+++ b/src/XAD/ChunkContainer.hpp
@@ -98,7 +98,7 @@ namespace xad
 {
 namespace detail
 {
-inline void* aligned_alloc(size_t alignment, size_t size)
+XAD_FORCE_INLINE void* aligned_alloc(size_t alignment, size_t size)
 {
     if (size < alignment)
         size = alignment;
@@ -236,6 +236,13 @@ class ChunkContainer
         ++idx_;
     }
 
+    void push_back(T && v)
+    {
+        check_space();
+
+        ::new (reinterpret_cast<value_type*>(chunkList_[chunk_]) + idx_) value_type(v);
+        ++idx_;
+    }
     template <class... Args>
     void emplace_back(Args&&... args)
     {
@@ -430,16 +437,16 @@ class ChunkContainer
     static size_type getLowPart(size_type i) { return i % chunk_size; }
     static size_type getNumElements(size_type chunks) { return chunks * chunk_size; }
 
-  private:
-    void check_space()
+ private:
+     void check_space()
     {
+        char* chunk ;
         if (idx_ == chunk_size)
         {
             if (chunk_ == chunkList_.size() - 1)
             {
-                char* chunk = reinterpret_cast<char*>(
-                    detail::aligned_alloc(ALIGNMENT, sizeof(value_type) * chunk_size));
-                if (chunk == NULL)
+                if ((chunk = reinterpret_cast<char*>(
+                    detail::aligned_alloc(ALIGNMENT, sizeof(value_type) * chunk_size))) == NULL)
                     throw std::bad_alloc();
                 chunkList_.push_back(chunk);
             }
@@ -458,7 +465,7 @@ class ChunkContainer
             detail::aligned_free(c);
         }
     }
-
+   
     std::vector<char*> chunkList_;
     size_type chunk_, idx_;
 };
diff --git a/src/XAD/Tape.hpp b/src/XAD/Tape.hpp
index 9e5467a..1d166ce 100644
--- a/src/XAD/Tape.hpp
+++ b/src/XAD/Tape.hpp
@@ -106,10 +106,7 @@ class Tape
 
     XAD_INLINE static void setActive(Tape* t)
     {
-        if (active_tape_ != nullptr)
-            throw TapeAlreadyActive();
-        else
-            active_tape_ = t;
+        active_tape_ != nullptr ? throw TapeAlreadyActive():active_tape_ = t;
     }
 
     XAD_INLINE static void deactivateAll() { active_tape_ = nullptr; }
@@ -161,7 +158,7 @@ class Tape
         auto numElements = last - first;
         auto completeChunks = numElements / 8;
         auto remainingElements = numElements % 8;
-        for (std::size_t i = 0; i < completeChunks; ++i) {
+        for (int i = 0; i < completeChunks; ++i) {
             registerInput(*first++);
             registerInput(*first++);
             registerInput(*first++);
@@ -207,7 +204,7 @@ XAD_INLINE void registerOutputs(std::vector<active_type>& v)
         auto numElements = last - first;
         auto completeChunks = numElements / 8;
         auto remainingElements = numElements % 8;
-        for (std::size_t i = 0; i < completeChunks; ++i) {
+        for (int i = 0; i < completeChunks; ++i) {
            registerOutput(*first++);
            registerOutput(*first++);
            registerOutput(*first++);
